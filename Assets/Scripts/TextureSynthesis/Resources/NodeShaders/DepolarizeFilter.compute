#pragma kernel Depolarize

Texture2D<float4> InputTex;
RWTexture2D<float4> OutputTex;

SamplerState SmpLinearRepeat;
SamplerState SmpLinearClamp;

uint width;
uint height;

#define PI 3.14159265f
#define TAU 6.2831853f

[numthreads(16, 16, 1)]
void Depolarize(uint3 id : SV_DispatchThreadID)
{
    float2 outputDims = float2(width, height);
    float2 uv = id.xy / outputDims;
    
    // Convert UV [0,1] to Centered [-1, 1]
    float2 centered = uv * 2.0 - 1.0;
    
    // Convert Cartesian to Polar
    float r = length(centered);
    float theta = atan2(centered.y, centered.x);
    
    // Normalize theta from [-PI, PI] to [0, 1]
    float normalizedAngle = theta / TAU;
    if (normalizedAngle < 0) normalizedAngle += 1.0;
    
    // Map normalized angle to Y coordinate (strip index 0-95)
    // Y is the angle
    float y = normalizedAngle; 

    // Map radius to X coordinate (pixel index 0-150)
    // Physical parameters
    float apexRadius = 0.332f;
    float stripLength = 2.5f;
    float totalRadius = stripLength + apexRadius;
    
    // r is 0..1 representing 0..totalRadius (if we fit the whole canopy in the square)
    // Actually, let's say the square (-1..1) covers the diameter of the canopy.
    // So r=1 is the edge of the canopy.
    
    // Inverse of: normalizedX = ((stripLength * normPos) + apexRadius) / totalRadius;
    // r = ((stripLength * normPos) + apexRadius) / totalRadius;
    // r * totalRadius = stripLength * normPos + apexRadius
    // normPos = (r * totalRadius - apexRadius) / stripLength
    
    float normPos = (r * totalRadius - apexRadius) / stripLength;
    
    float x = normPos;

    if (normPos < 0 || normPos > 1) {
        OutputTex[id.xy] = float4(0, 0, 0, 0); // Black/Transparent if out of bounds (hole or outside)
    } else {
        // Sample Input Texture
        // Input Texture is 151x96
        // x (0-1) maps to 0-150
        // y (0-1) maps to 0-95
        
        // Using SamplerState to handle interpolation
        // Coordinate system for SampleLevel is [0, 1]
        
        float4 result = InputTex.SampleLevel(SmpLinearRepeat, float2(x, y), 0);
        OutputTex[id.xy] = result;
    }
}
