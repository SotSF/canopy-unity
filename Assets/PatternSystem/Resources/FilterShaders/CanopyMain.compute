#pragma kernel CSMain

Texture2D<float4> InputTex;
RWStructuredBuffer<float3> dataBuffer;
RWTexture2D<float4> OutputTex;

bool polarize;
bool fitX;
bool fitY;

uint width;
uint height;

float2 rotate(in float2 xy, in float2 center, in float theta)
{
    float r = distance(center, xy);
    float startAngle = atan2(xy.y - center.y, xy.x - center.x);
    float newX = center.x + r * cos(theta + startAngle);
    float newY = center.y + r * sin(theta + startAngle);
    return float2(newX, newY);
}

// go from pixelSpace to width-normalized world space
float2 worldspace(in uint2 pixel, in float2 dimensions) {
    float pi = 3.14159265;
    float2 center = float2(0, 0);
    float apexRadius = 0.332f;
    float stripLength = 2.5f;
    float normalizedDimension = dimensions.x > dimensions.y ? dimensions.y : dimensions.x;
    float normalizedX = ((stripLength*pixel.x / 75.0f) + apexRadius) / (stripLength + apexRadius);
    return (normalizedDimension*rotate(float2(normalizedX, 0), center, 2 * pi*(pixel.y / 96.0f)) / 2) + (normalizedDimension / 2);
}

// go from arbitrary input tex size to a scaled-to-canopy size
float2 scale(in uint2 pixel, in float2 dimensions) {
    /*float normalizedDimension = dimensions.x > dimensions.y ? dimensions.y : dimensions.x;*/
}

[numthreads(25, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float2 coord = id.xy;
    if (polarize) {
        coord = worldspace(coord, float2(width, height));
    }
    OutputTex[id.xy] = InputTex[coord];
    dataBuffer[75 * id.y  + id.x] = InputTex[coord];
}
