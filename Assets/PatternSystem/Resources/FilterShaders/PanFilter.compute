#pragma kernel CSMain
Texture2D<float4> InputTex;
RWTexture2D<float4> OutputTex;

//Time in seconds
float time;
float frameTime;

//Speed in imageWidths/second
float speed;

//Pan direction in radians
float theta;

// Accumulated offset
float2 offset;

uint width;
uint height;

bool smoothTransitions;

//This function rotates a point (uint2 xy) theta radians around a center point
float2 rotate(in uint2 xy, in float2 center, in float theta)
{
    float r = distance(center, xy);
    float startAngle = atan2(xy.y - center.y, xy.x - center.x);
    float newX = center.x + r * cos(theta + startAngle);
    float newY = center.y + r * sin(theta + startAngle);
    return float2(newX, newY);
}

float4 bilerp(float4 p0q0, float4 p1q0, float4 p0q1, float4 p1q1, float2 offset)
{
    float a = offset.x % 1; // Get Interpolation factor for X direction.

    float4 q0 = lerp(p0q0, p1q0, a); // Interpolates top row in X direction.
    float4 q1 = lerp(p0q1, p1q1, a); // Interpolates bottom row in X direction.

    float b = offset.y % 1; // Get Interpolation factor for Y direction.
    return lerp(q0, q1, b); // Interpolate in Y direction.
}

[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint2 dimensions = uint2(width, height);
    float r = (speed * width * frameTime);
    float2 lastPosition = float2(offset.x + id.x, offset.y + id.y);
    float2 motionVector = float2(r * cos(theta), r * sin(theta));
    float2 newPosition = (lastPosition + motionVector) % dimensions;
    if (newPosition.x < 0) {
        newPosition.x += width;
    }
    if (newPosition.y < 0){
        newPosition.y += height;
    }
    if (smoothTransitions) {
        // Optionally bilerp for smooth transitions between pixels
        uint2 base = floor(newPosition);
        uint lastX = frac(lastPosition.x) > .5 ? ceil(lastPosition.x) : floor(lastPosition.x);
        uint lastY = frac(lastPosition.y) > .5 ? ceil(lastPosition.y) : floor(lastPosition.y);
        uint newX = newPosition.x > lastPosition.x ? ceil(newPosition.x) : floor(newPosition.x);
        uint newY = frac(newPosition.y) > .5 ? ceil(newPosition.y) : floor(newPosition.y);
        // First, pick closest pixel by integer (lastPosition)
        // Next, pick closest pixel in direction of travel (newPosition)
        // Then lerp?
        float4 p0q0 = InputTex[uint2(lastX, lastY)];
        float4 p0q1 = InputTex[uint2(newX, newY)];
        //float4 p1q0 = InputTex[(base + uint2(1, 0)) % dimensions];
        //float4 p1q1 = InputTex[(base + uint2(1, 1)) % dimensions];

        OutputTex[id.xy] = lerp(p0q0, p0q1, );
    }
    else {
        OutputTex[id.xy] = InputTex[newOffset];
    }
}