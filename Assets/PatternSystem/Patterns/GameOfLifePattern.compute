// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define ALIVE_THRESHOLD 0.01

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> InputTex;
RWTexture2D<float4> Frame;
RWStructuredBuffer<float3> dataBuffer;


float timeSeconds;
float brightness;
float period;
float cycleCount;

int gameOfLifeSample(int2 id, int x, int y) {
	int2 coords = int2((id.x + x + 75) % 75, (id.y + y + 96) % 96);
	return InputTex[coords].r > ALIVE_THRESHOLD ? 1 : 0;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	int neighbors = 0;

	// above
	neighbors += gameOfLifeSample(id.xy, -1, -1);
	neighbors += gameOfLifeSample(id.xy, 0, -1);
	neighbors += gameOfLifeSample(id.xy, 1, -1);

	// same level
	neighbors += gameOfLifeSample(id.xy, -1, 0);
	neighbors += gameOfLifeSample(id.xy, 1, 0);

	// below
	neighbors += gameOfLifeSample(id.xy, -1, 1);
	neighbors += gameOfLifeSample(id.xy, 0, 1);
	neighbors += gameOfLifeSample(id.xy, 1, 1);

	// Conway's game of life.
	// [DEAD] 1. Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.
	// [LIVE] 2. Any live cell with two or three live neighbours lives on to the next generation.
	// [DEAD] 3. Any live cell with more than three live neighbours dies, as if by overpopulation.
	// [LIVE] 4. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

	float val = 0;
	float self = InputTex[id.xy].r > ALIVE_THRESHOLD ? 1 : 0;
	if (self == 1) {
		if (neighbors >= 2 && neighbors <= 3) {
			val = 1;
		}
	}
	else {
		if (neighbors == 3) {
			val = 1;
		}
	}

	// TODO: insert actual code here!
	Frame[id.xy] = float4(val, val, val, 1);
	//Frame[id.xy] = float4(1 | (int)Frame[id.xy].r, 0 | (int)Frame[id.xy].g, 0, 0);
}
