// This is like declaring the "main" function of a C-family language, the thing that gets executed
#pragma kernel CSMain

// These are the pieces of data the GPU uses to communicate with the CPU
// "Result" is just an image file (a 2D array of float4s, which represent colors, eg <1,0,0,0> is red)
// "dataBuffer" is a 1D array of float3s, used to send the color values back in a format more usable by
// the rest of the code
// "timeSeconds" is the current time and passed in by the CPU so that eg sin() based oscillators will oscillate
Texture2D<float4> InputTex;
RWTexture2D<float4> Frame;
RWStructuredBuffer<float3> dataBuffer;

float timeSeconds;
float brightness;
float period;
float cycleCount;

float paddleLocation;
float4 ballData;

float2 convertToXY(float2 inputPolar) {

}

//The 'numthreads' declaration determines how many threads are used on the GPU
// you pass in X/Y/Z values - this program will use 64 threads concurrently
// and each one will get an X/Y value representing a pixel in the output image that
// it works on ("uint3 id")
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float radius = ballData[0];
	float stripIndex = 96 * (ballData[1] / (2 * 3.14159));
	if (((abs(radius - id.x) < 3) && (abs(stripIndex - id.y) < 3)) || id.x > 70){
		float4 color = float4(1, 1, 1, 1);
		Frame[id.xy] = brightness * color;
		dataBuffer[75 * id.y + id.x] = brightness * color;
	}
	else {
		float4 color = brightness * float4(id.x/75.0, 0, 0, 1);
		dataBuffer[75 * id.y + id.x] = color;
		Frame[id.xy] = color;
	}
}